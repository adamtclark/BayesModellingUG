P1 = runif(1)
R1 = runif(1)
P = c(P1, 1-P1)
R = c(R1, 1-R1)
if(sum(P^2) > sum(R^2)) {
matout[i,1] = sum(P^2/R^2)
matout[i,2] = sum(P^2)#var(P)
matout[i,3] = sum(R^2)#var(R)
matout[i,5] = sum(1/(R^2))
matout[i,4] = cov(R,1/R)
i = i+1
}
}
plot(matout[,3], matout[,5])
niter = 1e4
matout = matrix(nrow = niter, ncol = 5)
i = 1
while(i <= niter) {
P1 = runif(1)
R1 = runif(1)
P = c(P1, 1-P1)
R = c(R1, 1-R1)
if(sum(P^2) > sum(R^2)) {
matout[i,1] = sum(P^2/R^2)
matout[i,2] = sum(P^2)#var(P)
matout[i,3] = sum(R^2)#var(R)
matout[i,5] = sum(1/(R^2))
matout[i,4] = cov(R,1/R)
i = i+1
}
}
plot(matout[,3], matout[,5])
niter = 1e4
matout = matrix(nrow = niter, ncol = 5)
i = 1
while(i <= niter) {
P1 = runif(1)
R1 = runif(1)
P = c(P1, 1-P1)
R = c(R1, 1-R1)
if(sum(P^2) > sum(R^2)) {
matout[i,1] = sum(P^2/R^2)
matout[i,2] = sum(P^2)#var(P)
matout[i,3] = sum(R^2)#var(R)
matout[i,5] = sum(1/(R^2))
matout[i,4] = cov(R,1/R)
i = i+1
}
}
plot(matout[,3], matout[,5])
niter = 1e4
matout = matrix(nrow = niter, ncol = 5)
i = 1
while(i <= niter) {
P1 = runif(1)
R1 = runif(1)
P = c(P1, 1-P1)
R = c(R1, 1-R1)
if(sum(P^2) > sum(R^2)) {
matout[i,1] = sum(P^2/R^2)
matout[i,2] = sum(P^2)#var(P)
matout[i,3] = sum(R^2)#var(R)
matout[i,5] = sum(1/(R^2))
matout[i,4] = cov(R,1/R)
i = i+1
}
}
plot(matout[,3], matout[,5])
plot(matout[,3], matout[,5], log = "y")
plot(matout[,3], matout[,5], log = "xy")
plot(matout[,3], matout[,5], log = "y")
#mean(xy) = mean(x)*mean(y) + cov(xy)
# for x = P, y = 1/R...
#sum(P^2/R^2)/n = sum(P^2)/sum(R^2) + cov(P, 1/R)
plot(matout[,1], matout[,2]*matout[,5]+matout[,4])
#mean(xy) = mean(x)*mean(y) + cov(xy)
# for x = P, y = 1/R...
#sum(P^2/R^2)/n = sum(P^2)/sum(R^2) + cov(P, 1/R)
plot(matout[,1], matout[,2]*matout[,5]+matout[,4], log = "xy")
abline(a=0, b = 1, lty=2, col = 2)
min(matout[,2]*matout[,5])
3*5*3
3*5*3/12
8+15/30
2*(150/140)  + (1/30) * (15)
# Load necessary libraries
library(dplyr)
library(ggplot2)
# Set seed for reproducibility
set.seed(123)
# Parameters
mortality <- 'deterministic' # 'deterministic' or 'random'
fecundity <- 'dependent'     # 'fixed' or 'dependent'
deltaE <- 0                 # How much the environment changes in each patch per turn
tmax <- 10000
J <- 20                     # Number of species
K <- 14                     # Number of environmental dimensions
M <- 625                    # Number of sites
uIV <- 0.1                  # Fraction uIV
nprop <- 10                 # Number of propagules (initial and each turn for fixed fecundity)
fecund <- 0.5               # Number of propagules per capita (for abundance-dependent fecundity)
death <- 0.01               # Fraction of dead individuals per turn
E <- matrix(runif(K * M), nrow = K, ncol = M)             # Environmental values
Eopt <- matrix(runif(J * K), nrow = J, ncol = K)         # Species environmental preferences
alld <- sqrt(rowSums((Eopt %*% t(E) - E)^2))              # Calculate distances
mud <- mean(alld)
Eopt
dim(Eopt)
dim(E)
alld <- sqrt(rowSums((Eopt %*% (E) - E)^2))              # Calculate distances
logistfun = function(tm, N0, r, K) {
K/((K-N0)/N0*exp(r*-tm)+1)
}
tm = seq(0, 10, by = 0.1)
logistfun = function(tm, N0, r, K) {
K/((K-N0)/N0*exp(r*-tm)+1)
}
plot(tm, logistfun(tm, 0.1, 1, 1))
plot(tm, logistfun(tm, 0.1, 1, 1), type = "l")
logistfun(tm = 1, N0 = 0.1, r = 2, K = 1)
logistfun(tm = 1*(2/1), N0 = 0.1, r = 2, K = 1)
logistfun(tm = 1,       N0 = 0.1, r = 2, K = 1)
logistfun(tm = 1*(2/1), N0 = 0.1, r = 1, K = 1)
logistfun(tm = 1,       N0 = 0.1*2, r = 2, K = 2)
logistfun(tm = 1*(2/1), N0 = 0.1*1, r = 1, K = 1)
logistfun(tm = 1,       N0 = 0.1*2, r = 2, K = 2)/2
logistfun(tm = 1*(2/1), N0 = 0.1*1, r = 1, K = 1)
0.8*0.01
0.8*0.01/0.01
(0.8 * 0.01)/(0.01 * 0.8 + 0.99*0.01)
(0.8 * 0.3)/(0.03 * 0.8 + 0.7*0.01)
(0.8 * 0.3)/(0.3 * 0.8 + 0.7*0.01)
set.seed(1234) # makes sure we all use the same random seed
N = 1e3 # fancy way of writing 1000
low = c(rep(1, N*0.01), rep(0, N*0.99))
high = c(rep(1, N*0.3), rep(0, N*0.7))
# make an empty vector for test results
test_low = numeric(N)
# 80% chance of positive test given sick
test_low[low == 1] = rbinom(n = N*0.01, size = 1, prob = 0.8)
# 1% chance of positive test given healthy
test_low[low == 0] = rbinom(n = N*0.99, size = 1, prob = 0.01)
# repeat for high
test_high = numeric(N)
test_high[high == 1] = rbinom(n = N*0.3, size = 1, prob = 0.8)
test_high[high == 0] = rbinom(n = N*0.7, size = 1, prob = 0.01)
sum(test_low) # number of positive results in low scenario
sum(test_high) # number of positive results in high scenario
sum(test_low[low==1])/sum(test_low)
sum(test_high[high==1])/sum(test_high)
knitr::opts_chunk$set(echo = TRUE)
# plot globe
library(globe)
library(sf)
library(spData) ## For `world`, an sf MULTIPOLYGON object
globeearth(eye=list(runif(1,-80,80),runif(1,-180,180)))
## Create an sf POINTS object
set.seed(0)
lat <- runif(10, -70, 70)
lon <- runif(10, -180, 180)
#points <- expand.grid(lon, lat)  # Note that I reversed OP's ordering of lat/long
points <- data.frame(lon,lat)
pts <- st_as_sf(points, coords=1:2, crs=4326)
## Find which points fall over land
ii <- !is.na(as.numeric(st_intersects(pts, world)))
# function to sample from globe and return whether water or land
# returns TRUE for water
globe_toss <- function(plot=FALSE) {
lat <- runif(1,-70,70)
lon <- runif(1,-180,180)
pts <- st_as_sf( data.frame(lon,lat) , coords=1:2, crs=4326)
if ( plot==TRUE ) globeearth(eye=list(lat,lon))
return( c(lat,lon, is.na(as.numeric(st_intersects(pts, world))) ) )
}
globe_toss()
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
globe_toss(plot = TRUE)
water = 0 # number of water samples
land = 0 # number of land samples
n = 0 # number of trials
while(n <= 100) {
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
} else {
land = land+1
}
n = n+1 # increment n
}
print(c(water, land))
print(c(water, land)/n)
## R code 2.3
# define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
likelihood <- dbinom( 6 , size=9 , prob=p_grid )
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
## R code 2.4
plot( p_grid , posterior , type="b" ,
xlab="probability of water" , ylab="posterior probability" )
mtext( "20 points" )
dbinom( 6 , size=9 , prob=p_grid )
dbinom( 6 , size=9 , prob=p_grid )
6/9
6/9
abline(v = 0.75)
abline(v = 0.67)
## R code 2.3
# define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define prior
prior <- rep( 1 , 20 )
# compute likelihood at each value in grid
likelihood <- dbinom( 6 , size=9 , prob=p_grid )
# compute product of likelihood and prior
unstd.posterior <- likelihood * prior
# standardize the posterior, so it sums to 1
posterior <- unstd.posterior / sum(unstd.posterior)
## R code 2.4
plot( p_grid , posterior , type="b" ,
xlab="probability of water" , ylab="posterior probability" )
mtext( "20 points" )
## R code 2.5
prior <- ifelse( p_grid < 0.5 , 0 , 1 )
prior <- exp( -5*abs( p_grid - 0.5 ) )
## R code 2.6
library(rethinking)
globe.qa <- quap(
alist(
W ~ dbinom( W+L ,p) ,  # binomial likelihood
p ~ dunif(0,1)     # uniform prior
) ,
data=list(W=6,L=3) )
# display summary of quadratic approximation
precis( globe.qa )
## R code 2.7
# analytical calculation
W <- 6
L <- 3
curve( dbeta( x , W+1 , L+1 ) , from=0 , to=1 )
# quadratic approximation
curve( dnorm( x , 0.67 , 0.16 ) , lty=2 , add=TRUE )
?curve
#### in-class example
# define grid
p_grid <- seq( from=0 , to=1 , length.out=20 )
# define priors
prior_unif <- rep( 1 , 20 )
prior_unif = prior_unif/sum(prior_unif)
prior_inform <- rep( 1 , 20 )
prior_inform[p_grid > 0.7 & p_grid < 0.8] = 2
prior_inform = prior_inform/sum(prior_inform)
## plot priors
matplot( p_grid , cbind(prior_unif, prior_inform) , type="b" ,
xlab="probability of water" , ylab="prior probability")
##########################################################
# try updating posteriors (run multiple itmes)
n = n+1
water = water + globe_toss(TRUE)[3]
paste("water:", print(water == 1))
# compute likelihood at each value in grid
likelihood <- dbinom( water , size=n , prob=p_grid )
# compute product of likelihood and prior
unstd.posterior_unif <- likelihood * prior_unif
unstd.posterior_inform <- likelihood * prior_inform
# standardize the posterior, so it sums to 1
posterior_unif <- unstd.posterior_unif / sum(unstd.posterior_unif)
posterior_inform <- unstd.posterior_inform / sum(unstd.posterior_inform)
## plot posteriors
matplot( p_grid , cbind(posterior_unif, posterior_inform) , type="b" ,
xlab="probability of water" , ylab="prior probability")
title(paste("total samples =", n))
abline(v = 0.71, lty = 3)
p_grid <- seq( from=0 , to=1 , length.out=20 )
p_grid
dbinom( water , size=n , prob=p_grid )
set.seed(1234) # make sure we all get the same string of random numbers
water = 0 # number of water samples
land = 0 # number of land samples
n = 0 # number of trials
while(n <= 10) { # loop 100 times
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
} else {
land = land+1
}
n = n+1 # increment n
}
water/n
set.seed(4321) # make sure we all get the same string of random numbers
water = 0 # number of water samples
land = 0 # number of land samples
n = 0 # number of trials
while(n <= 10) { # loop 100 times
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
} else {
land = land+1
}
n = n+1 # increment n
}
water/n
water
n
set.seed(4321) # make sure we all get the same string of random numbers
water = 0 # number of water samples
land = 0 # number of land samples
n = 0 # number of trials
while(n <= 10) { # loop 100 times
n = n+1 # increment n
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
} else {
land = land+1
}
}
water
n
water
land
set.seed(4321) # make sure we all get the same string of random numbers
water = 0 # number of water samples
while(n < 10) { # loop 100 times
n = n+1 # increment n
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
}
}
water
set.seed(4321) # make sure we all get the same string of random numbers
water = 0 # number of water samples
n = 0
while(n < 10) { # loop 100 times
n = n+1 # increment n
toss_result = globe_toss(plot = FALSE) # toss the globe
if(toss_result[3]==1) { # record result
water = water+1
}
}
water
water
n
# compute likelihood at each value in grid
likelihood <- dbinom( water , size=n , prob=p_grid )
# compute likelihood at each value in grid
likelihood <- dbinom( water , size=n , prob=p_grid )
## R code 2.4
plot( p_grid , posterior , type="b" ,
xlab="probability of water" , ylab="likelihood of data given p" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical line at p = 6/10
water
n
# compute likelihood at each value in grid
likelihood <- dbinom( water , size=n , prob=p_grid )
## R code 2.4
plot( p_grid , likelihood , type="b" ,
xlab="probability of water" , ylab="likelihood of data given p" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical line at p = 6/10
# compute likelihood at each value in grid
likelihood <- dbinom( water , size=n , prob=p_grid )
## R code 2.4
plot( p_grid , likelihood , type="b" ,
xlab="probability of water" , ylab="likelihood of data given p" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_flat <- rep( 1/20 , 20 )
unstd.posterior <- likelihood * prior
plot( p_grid , likelihood , type="b" ,
xlab="probability of water" , ylab="posterior" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_flat <- rep( 1/20 , 20 )
unstd.posterior <- likelihood * prior
plot( p_grid , unstd.posterior , type="b" ,
xlab="probability of water" , ylab="posterior" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
likelihood
likelihood <- dbinom( water , size=n , prob=p_grid )
prior_flat
unstd.posterior <- likelihood * prior_flat
plot( p_grid , unstd.posterior , type="b" ,
xlab="probability of water" , ylab="posterior" )
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative{p_grid >= 0.6 & p_grid <= 0.9} = 2
prior_informative <- rep( 1 , 20 )
prior_informative{p_grid >= 0.6 & p_grid <= 0.9} = 2
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.6 & p_grid <= 0.9] = 2
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, prior_informative) , type="b" ,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.6 & p_grid <= 0.9] = 2
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" ,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.6 & p_grid <= 0.9] = 2
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" , pch = 1:2,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
legend("topleft", c("flat", "informative"), col = 1:2, pch = 1:2)
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.65 & p_grid <= 0.85] = 3
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" , pch = 1:2,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
legend("topleft", c("flat", "informative"), col = 1:2, pch = 1:2)
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.25 & p_grid <= 0.35] = 3
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" , pch = 1:2,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
legend("topleft", c("flat", "informative"), col = 1:2, pch = 1:2)
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.55 & p_grid <= 0.65] = 3
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" , pch = 1:2,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
legend("topleft", c("flat", "informative"), col = 1:2, pch = 1:2)
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
prior_informative <- rep( 1 , 20 )
prior_informative[p_grid >= 0.4 & p_grid <= 0.5] = 3
prior_informative = prior_informative/sum(prior_informative) # standardise to sum to 1
unstd.posterior_inform <- likelihood * prior_informative
matplot( p_grid , cbind(unstd.posterior, unstd.posterior_inform) , type="b" , pch = 1:2,
xlab="probability of water" , ylab="posterior")
mtext( "20 points, based on 10 draws" )
legend("topleft", c("flat", "informative"), col = 1:2, pch = 1:2)
abline(v = 6/10, lty = 2) # draw a vertical dashed line at p = 6/10
abline(v = 0.75, lty = 3) # draw a vertical dotted line at the "true" value of 75%
19177.98+2116.92+25296.94
14928.36+2116.92+25296.94
123.98*2*3*4
123.98*2*3
require(partitionBEFsp)
?partitionBEFsp
require(pttstability)
?pttstability
############ Example 2: brms
#install.packages("brms")
require(brms)
setwd("~/Dropbox/Teaching/Graz/BayesStats/BayesModellingUG/meetings/K5")
d = read.csv("e120_data.csv")
head(d)
?brms
install.packages(c("StanHeaders","rstan"), type="source")
install.packages(c("StanHeaders", "rstan"), type = "source")
ls()
install.packages("brms")
